{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"[ ] 15 [ ] 13 [ ] 13 [ ] 18 Dark magics about variable names in python Change Log | API | Playground Installation pip install -U varname Features Core features: Retrieving names of variables a function/class call is assigned to from inside it, using varname . Retrieving variable names directly, using nameof Detecting next immediate attribute name, using will Other helper APIs (built based on core features): A value wrapper to store the variable name that a value is assigned to, using Wrapper A decorator to register __varname__ to functions/classes, using register A debug function to print variables with their names and values Credits Thanks goes to these awesome people/projects: @alexmojaki executing Special thanks to @HanyuuLu to give up the name varname in pypi for this project. Usage Retrieving the variable names using varname(...) From inside a function from varname import varname def function (): return varname () func = function () # func == 'func' When there are intermediate frames: def wrapped (): return function () def function (): # retrieve the variable name at the 2nd frame from this one return varname ( frame = 2 ) func = wrapped () # func == 'func' Or use ignore to ignore the wrapped frame: def wrapped (): return function () def function (): return varname ( ignore = wrapped ) func = wrapped () # func == 'func' Calls from standard libraries are ignored by default: import asyncio async def function (): return varname () func = asyncio . run ( function ()) # func == 'func' Retrieving name of a class instance class Foo : def __init__ ( self ): self . id = varname () def copy ( self ): # also able to fetch inside a method call copied = Foo () # copied.id == 'copied' copied . id = varname () # assign id to whatever variable name return copied foo = Foo () # foo.id == 'foo' foo2 = foo . copy () # foo2.id == 'foo2' Multiple variables on Left-hand side # since v0.5.4 def func (): return varname ( multi_vars = True ) a = func () # a == ('a', ) a , b = func () # (a, b) == ('a', 'b') [ a , b ] = func () # (a, b) == ('a', 'b') # hierarchy is also possible a , ( b , c ) = func () # (a, b, c) == ('a', 'b', 'c') Some unusual use def function (): return varname () func = [ function ()] # func == ['func'] func = [ function (), function ()] # func == ['func', 'func'] func = function (), function () # func = ('func', 'func') func = func1 = function () # func == func1 == 'func' # a warning will be shown # since you may not want func1 to be 'func' x = func ( y = func ()) # x == 'x' # get part of the name func_abc = function ()[ - 3 :] # func_abc == 'abc' # function alias supported now function2 = function func = function2 () # func == 'func' a = lambda : 0 a . b = function () # a.b == 'b' # Since v0.1.3 # We can ask varname to raise exceptions # if it fails to detect the variable name def get_name ( raise_exc ): return varname ( raise_exc = raise_exc ) a = {} a [ 'b' ] = get_name ( True ) # VarnameRetrievingError a [ 'b' ] = get_name ( False ) # None The decorator way to register __varname__ to functions/classes Registering __varname__ to functions from varname.helpers import register @register def function (): return __varname__ func = function () # func == 'func' # arguments also allowed (frame, ignore and raise_exc) @register ( frame = 2 ) def function (): return __varname__ def wrapped (): return function () func = wrapped () # func == 'func' Registering __varname__ as a class property @register class Foo : ... foo = Foo () # foo.__varname__ == 'foo' Getting variable names directly using nameof from varname import varname , nameof a = 1 nameof ( a ) # 'a' b = 2 nameof ( a , b ) # ('a', 'b') def func (): return varname () + '_suffix' f = func () # f == 'f_suffix' nameof ( f ) # 'f' # get full names of (chained) attribute calls func . a = func nameof ( func . a , full = True ) # 'func.a' func . a . b = 1 nameof ( func . a . b , full = True ) # 'func.a.b' Detecting next immediate attribute name from varname import will class AwesomeClass : def __init__ ( self ): self . will = None def permit ( self ): self . will = will ( raise_exc = False ) if self . will == 'do' : # let self handle do return self raise AttributeError ( 'Should do something with AwesomeClass object' ) def do ( self ): if self . will != 'do' : raise AttributeError ( \"You don't have permission to do\" ) return 'I am doing!' awesome = AwesomeClass () awesome . do () # AttributeError: You don't have permission to do awesome . permit () # AttributeError: Should do something with AwesomeClass object awesome . permit () . do () == 'I am doing!' Value wrapper from varname.helpers import Wrapper foo = Wrapper ( True ) # foo.name == 'foo' # foo.value == True bar = Wrapper ( False ) # bar.name == 'bar' # bar.value == False def values_to_dict ( * args ): return { val . name : val . value for val in args } mydict = values_to_dict ( foo , bar ) # {'foo': True, 'bar': False} Debugging with debug from varname.helpers import debug a = 'value' b = object () debug ( a ) # DEBUG: a='value' debug ( b ) # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b ) # DEBUG: a='value' # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b , merge = True ) # DEBUG: a='value', b=<object object at 0x2b70580e5f20> debug ( a , repr = False , prefix = '' ) # a=value Reliability and limitations varname is all depending on executing package to look for the node. The node executing detects is ensured to be the correct one (see this ). It partially works with environments where other AST magics apply, including pytest , ipython , macropy , birdseye , reticulate with R , etc. Neither executing nor varname is 100% working with those environments. Use it at your own risk. For example: This will not work with pytest : a = 1 assert nameof ( a ) == 'a' # do this instead name_a = nameof ( a ) assert name_a == 'a' R with reticulate .","title":"Home"},{"location":"#installation","text":"pip install -U varname","title":"Installation"},{"location":"#features","text":"Core features: Retrieving names of variables a function/class call is assigned to from inside it, using varname . Retrieving variable names directly, using nameof Detecting next immediate attribute name, using will Other helper APIs (built based on core features): A value wrapper to store the variable name that a value is assigned to, using Wrapper A decorator to register __varname__ to functions/classes, using register A debug function to print variables with their names and values","title":"Features"},{"location":"#credits","text":"Thanks goes to these awesome people/projects: @alexmojaki executing Special thanks to @HanyuuLu to give up the name varname in pypi for this project.","title":"Credits"},{"location":"#usage","text":"","title":"Usage"},{"location":"#retrieving-the-variable-names-using-varname","text":"From inside a function from varname import varname def function (): return varname () func = function () # func == 'func' When there are intermediate frames: def wrapped (): return function () def function (): # retrieve the variable name at the 2nd frame from this one return varname ( frame = 2 ) func = wrapped () # func == 'func' Or use ignore to ignore the wrapped frame: def wrapped (): return function () def function (): return varname ( ignore = wrapped ) func = wrapped () # func == 'func' Calls from standard libraries are ignored by default: import asyncio async def function (): return varname () func = asyncio . run ( function ()) # func == 'func' Retrieving name of a class instance class Foo : def __init__ ( self ): self . id = varname () def copy ( self ): # also able to fetch inside a method call copied = Foo () # copied.id == 'copied' copied . id = varname () # assign id to whatever variable name return copied foo = Foo () # foo.id == 'foo' foo2 = foo . copy () # foo2.id == 'foo2' Multiple variables on Left-hand side # since v0.5.4 def func (): return varname ( multi_vars = True ) a = func () # a == ('a', ) a , b = func () # (a, b) == ('a', 'b') [ a , b ] = func () # (a, b) == ('a', 'b') # hierarchy is also possible a , ( b , c ) = func () # (a, b, c) == ('a', 'b', 'c') Some unusual use def function (): return varname () func = [ function ()] # func == ['func'] func = [ function (), function ()] # func == ['func', 'func'] func = function (), function () # func = ('func', 'func') func = func1 = function () # func == func1 == 'func' # a warning will be shown # since you may not want func1 to be 'func' x = func ( y = func ()) # x == 'x' # get part of the name func_abc = function ()[ - 3 :] # func_abc == 'abc' # function alias supported now function2 = function func = function2 () # func == 'func' a = lambda : 0 a . b = function () # a.b == 'b' # Since v0.1.3 # We can ask varname to raise exceptions # if it fails to detect the variable name def get_name ( raise_exc ): return varname ( raise_exc = raise_exc ) a = {} a [ 'b' ] = get_name ( True ) # VarnameRetrievingError a [ 'b' ] = get_name ( False ) # None","title":"Retrieving the variable names using varname(...)"},{"location":"#the-decorator-way-to-register-__varname__-to-functionsclasses","text":"Registering __varname__ to functions from varname.helpers import register @register def function (): return __varname__ func = function () # func == 'func' # arguments also allowed (frame, ignore and raise_exc) @register ( frame = 2 ) def function (): return __varname__ def wrapped (): return function () func = wrapped () # func == 'func' Registering __varname__ as a class property @register class Foo : ... foo = Foo () # foo.__varname__ == 'foo'","title":"The decorator way to register __varname__ to functions/classes"},{"location":"#getting-variable-names-directly-using-nameof","text":"from varname import varname , nameof a = 1 nameof ( a ) # 'a' b = 2 nameof ( a , b ) # ('a', 'b') def func (): return varname () + '_suffix' f = func () # f == 'f_suffix' nameof ( f ) # 'f' # get full names of (chained) attribute calls func . a = func nameof ( func . a , full = True ) # 'func.a' func . a . b = 1 nameof ( func . a . b , full = True ) # 'func.a.b'","title":"Getting variable names directly using nameof"},{"location":"#detecting-next-immediate-attribute-name","text":"from varname import will class AwesomeClass : def __init__ ( self ): self . will = None def permit ( self ): self . will = will ( raise_exc = False ) if self . will == 'do' : # let self handle do return self raise AttributeError ( 'Should do something with AwesomeClass object' ) def do ( self ): if self . will != 'do' : raise AttributeError ( \"You don't have permission to do\" ) return 'I am doing!' awesome = AwesomeClass () awesome . do () # AttributeError: You don't have permission to do awesome . permit () # AttributeError: Should do something with AwesomeClass object awesome . permit () . do () == 'I am doing!'","title":"Detecting next immediate attribute name"},{"location":"#value-wrapper","text":"from varname.helpers import Wrapper foo = Wrapper ( True ) # foo.name == 'foo' # foo.value == True bar = Wrapper ( False ) # bar.name == 'bar' # bar.value == False def values_to_dict ( * args ): return { val . name : val . value for val in args } mydict = values_to_dict ( foo , bar ) # {'foo': True, 'bar': False}","title":"Value wrapper"},{"location":"#debugging-with-debug","text":"from varname.helpers import debug a = 'value' b = object () debug ( a ) # DEBUG: a='value' debug ( b ) # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b ) # DEBUG: a='value' # DEBUG: b=<object object at 0x2b70580e5f20> debug ( a , b , merge = True ) # DEBUG: a='value', b=<object object at 0x2b70580e5f20> debug ( a , repr = False , prefix = '' ) # a=value","title":"Debugging with debug"},{"location":"#reliability-and-limitations","text":"varname is all depending on executing package to look for the node. The node executing detects is ensured to be the correct one (see this ). It partially works with environments where other AST magics apply, including pytest , ipython , macropy , birdseye , reticulate with R , etc. Neither executing nor varname is 100% working with those environments. Use it at your own risk. For example: This will not work with pytest : a = 1 assert nameof ( a ) == 'a' # do this instead name_a = nameof ( a ) assert name_a == 'a' R with reticulate .","title":"Reliability and limitations"},{"location":"CHANGELOG/","text":"v0.6.0 Changed: Wrapper , register and debug moved to varname.helpers Argument caller changed to frame across all APIs ignore accepting module, filename, function, (function, num_decorators), (module, qualname) and (filename, qualname) Removed: inject (Use helpers.regiester instead) inject_varname (Use helpers.regiester instead) namedtuple Added: Arguments frame and ignore to Wrapper helpers.register as a decorator for functions v0.5.6 Add ignore argument to varname to ignore frames that are not counted by caller Deprecate inject_varname , use register instead v0.5.5 Deprecate inject and use inject_varname decorator instead v0.5.4 Allow varname.varname to receive multiple variables on the left-hand side v0.5.3 Add debug function Deprecate namedtuple (will be removed in 0.6.0 ) v0.5.2 Move messaging of weird nameof calls from _bytecode_nameof to nameof . Disallow full to be used when _bytecode_nameof needs to be invoked. v0.5.1 Add better messaging for weird nameof calls v0.5.0 Allow nameof to retrieve full name of chained attribute calls Add __all__ to the module so that only desired APIs are exposed when from varname import * Give more hints on nameof being called in a weird way when no soucecode available. v0.4.0 Change default of raise_exc to True for all related APIs Deprecate var_0 Get rid of VarnameRetrievingWarning . v0.3.0 Use sys._getframe instead of inspect.stack for efficiency (#9) Add alternative way of testing bytecode nameof (#10) Drop support for pytest, don't try to find node when executing fails Remodel will for better logic Support attributes in varname and nameof (#14) v0.2.0 Fix #5 and fit nameof in more cases v0.1.7 Add inject function v0.1.6 Fit situations when frames cannot be fetched Add shortcut for namedtuple v0.1.5 Fix will from a property call v0.1.4 Add will to detect next immediate attribute name v0.1.3 Add arugment raise_exc for varname to raise an exception instead of returning var_<index> v0.1.2 Add function nameof v0.1.1 Add a value wrapper Wrapper class v0.1.0 Implement varname function","title":"Change Log"},{"location":"CHANGELOG/#v060","text":"Changed: Wrapper , register and debug moved to varname.helpers Argument caller changed to frame across all APIs ignore accepting module, filename, function, (function, num_decorators), (module, qualname) and (filename, qualname) Removed: inject (Use helpers.regiester instead) inject_varname (Use helpers.regiester instead) namedtuple Added: Arguments frame and ignore to Wrapper helpers.register as a decorator for functions","title":"v0.6.0"},{"location":"CHANGELOG/#v056","text":"Add ignore argument to varname to ignore frames that are not counted by caller Deprecate inject_varname , use register instead","title":"v0.5.6"},{"location":"CHANGELOG/#v055","text":"Deprecate inject and use inject_varname decorator instead","title":"v0.5.5"},{"location":"CHANGELOG/#v054","text":"Allow varname.varname to receive multiple variables on the left-hand side","title":"v0.5.4"},{"location":"CHANGELOG/#v053","text":"Add debug function Deprecate namedtuple (will be removed in 0.6.0 )","title":"v0.5.3"},{"location":"CHANGELOG/#v052","text":"Move messaging of weird nameof calls from _bytecode_nameof to nameof . Disallow full to be used when _bytecode_nameof needs to be invoked.","title":"v0.5.2"},{"location":"CHANGELOG/#v051","text":"Add better messaging for weird nameof calls","title":"v0.5.1"},{"location":"CHANGELOG/#v050","text":"Allow nameof to retrieve full name of chained attribute calls Add __all__ to the module so that only desired APIs are exposed when from varname import * Give more hints on nameof being called in a weird way when no soucecode available.","title":"v0.5.0"},{"location":"CHANGELOG/#v040","text":"Change default of raise_exc to True for all related APIs Deprecate var_0 Get rid of VarnameRetrievingWarning .","title":"v0.4.0"},{"location":"CHANGELOG/#v030","text":"Use sys._getframe instead of inspect.stack for efficiency (#9) Add alternative way of testing bytecode nameof (#10) Drop support for pytest, don't try to find node when executing fails Remodel will for better logic Support attributes in varname and nameof (#14)","title":"v0.3.0"},{"location":"CHANGELOG/#v020","text":"Fix #5 and fit nameof in more cases","title":"v0.2.0"},{"location":"CHANGELOG/#v017","text":"Add inject function","title":"v0.1.7"},{"location":"CHANGELOG/#v016","text":"Fit situations when frames cannot be fetched Add shortcut for namedtuple","title":"v0.1.6"},{"location":"CHANGELOG/#v015","text":"Fix will from a property call","title":"v0.1.5"},{"location":"CHANGELOG/#v014","text":"Add will to detect next immediate attribute name","title":"v0.1.4"},{"location":"CHANGELOG/#v013","text":"Add arugment raise_exc for varname to raise an exception instead of returning var_<index>","title":"v0.1.3"},{"location":"CHANGELOG/#v012","text":"Add function nameof","title":"v0.1.2"},{"location":"CHANGELOG/#v011","text":"Add a value wrapper Wrapper class","title":"v0.1.1"},{"location":"CHANGELOG/#v010","text":"Implement varname function","title":"v0.1.0"},{"location":"api/varname.core/","text":"module varname . core </> Provide core features for varname Functions nameof ( var , *more_vars , frame , full ) (str or (str)) \u2014 Get the names of the variables passed in </> varname ( frame , ignore , multi_vars , raise_exc ) (Union(str, (str or tuple), nonetype)) \u2014 Get the name of the variable(s) that assigned by function call or class instantiation. </> will ( frame , raise_exc ) (str, optional) \u2014 Detect the attribute name right immediately after a function call. </> function varname.core . varname ( frame=1 , ignore=None , multi_vars=False , raise_exc=True ) </> Get the name of the variable(s) that assigned by function call or class instantiation. To debug and specify the right frame and ignore arguments, you can set debug on and see how the frames are ignored or selected: >>> from varname import config >>> config . debug = True Parameters frame (int, optional) \u2014 N th frame used to retrieve the variable name. This means N-1 intermediate frames will be skipped. Note that the frames match ignore will not be counted. See ignore for details. ignore (Union(module, str, function, (module, str, or nonetype, str), (function, int), list of union(module, str, function, (module, str, or nonetype, str), (function, int)), nonetype), optional) \u2014 Frames to be ignored in order to reach the N th frame. These frames will not be counted to skip within that N-1 frames. You can specify: - A module (or filename of a module). Any calls from it and its submodules will be ignored. - A function. If it looks like it might be a decorated function, a MaybeDecoratedFunctionWarning will be shown. - Tuple of a function and a number of additional frames that should be skipped just before reaching this function in the stack. This is typically used for functions that have been decorated with a 'classic' decorator that replaces the function with a wrapper. In that case each such decorator involved should be counted in the number that's the second element of the tuple. - Tuple of a module (or filename) and qualified name (qualname). You can use Unix shell-style wildcards to match the qualname. Otherwise the qualname must appear exactly once in the module/file. By default, all calls from varname package, python standard libraries and lambda functions are ignored. multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS). If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a VarnameRetrievingError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failed to retrieve the name. Returns (Union(str, (str or tuple), nonetype)) The variable name, or None when raise_exc is False and we failed to retrieve the variable name. A tuple or a hierarchy (tuple of tuples) of variable names when multi_vars is True . Raises UserWarning \u2014 When there are multiple target in the assign node. (e.g: a = b = func() , in such a case, b == 'a' , may not be the case you want) VarnameRetrievingError \u2014 When there is invalid variables or invalid number of variables used on the LHS; or when we are unable to retrieve the variable name and raise_exc is set to True . function varname.core . will ( frame=1 , raise_exc=True ) </> Detect the attribute name right immediately after a function call. Examples >>> class AwesomeClass : >>> def __init__ ( self ): >>> self . will = None >>> def permit ( self ): >>> self . will = will () >>> if self . will == 'do' : >>> # let self handle do >>> return self >>> raise AttributeError ( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do ( self ): >>> if self . will != 'do' : >>> raise AttributeError ( \"You don't have permission to do\" ) >>> return 'I am doing!' >>> awesome = AwesomeClass () >>> # AttributeError: You don't have permission to do >>> awesome . do () >>> # AttributeError: Should do something with AwesomeClass object >>> awesome . permit () >>> awesome . permit () . do () == 'I am doing!' Parameters frame (int, optional) \u2014 At which frame this function is called. raise_exc (bool, optional) \u2014 Raise exception we failed to detect Returns (str, optional) The attribute name right after the function call If there is no attribute attached and raise_exc is False Raises VarnameRetrievingError \u2014 When raise_exc is True and we failed to detect the attribute name (including not having one) function varname.core . nameof ( var , *more_vars , frame=1 , full=None ) </> Get the names of the variables passed in Examples >>> a = 1 >>> nameof ( a ) # 'a' >>> b = 2 >>> nameof ( a , b ) # ('a', 'b') >>> x = lambda : None >>> x . y = 1 >>> nameof ( x . y , full = True ) # 'x.y' Note This function works with the environments where source code is available, in other words, the callee's node can be retrieved by executing . In some cases, for example, running code from python shell/REPL or from exec / eval , we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Parameters var \u2014 The variable to retrieve the name of *more_vars \u2014 Other variables to retrieve the names of frame (int, optional) \u2014 The depth of the frame (this function) is called. This is useful if you want to wrap this function. Note that the calls from varname and builtin modules are ignored. full (bool, optional) \u2014 Whether report the full path of the variable. For example: nameof(a.b.c, full=True) give you a.b.c instead of c Returns (str or (str)) The names of variables passed in. If a single varialble is passed, return the name of it. If multiple variables are passed, return a tuple of their names. Raises VarnameRetrievingError \u2014 When the callee's node cannot be retrieved or trying to retrieve the full name of non attribute series calls.","title":"varname.core"},{"location":"api/varname.core/#varnamecore","text":"</> Provide core features for varname Functions nameof ( var , *more_vars , frame , full ) (str or (str)) \u2014 Get the names of the variables passed in </> varname ( frame , ignore , multi_vars , raise_exc ) (Union(str, (str or tuple), nonetype)) \u2014 Get the name of the variable(s) that assigned by function call or class instantiation. </> will ( frame , raise_exc ) (str, optional) \u2014 Detect the attribute name right immediately after a function call. </> function","title":"varname.core"},{"location":"api/varname.core/#varnamecorevarname","text":"</> Get the name of the variable(s) that assigned by function call or class instantiation. To debug and specify the right frame and ignore arguments, you can set debug on and see how the frames are ignored or selected: >>> from varname import config >>> config . debug = True Parameters frame (int, optional) \u2014 N th frame used to retrieve the variable name. This means N-1 intermediate frames will be skipped. Note that the frames match ignore will not be counted. See ignore for details. ignore (Union(module, str, function, (module, str, or nonetype, str), (function, int), list of union(module, str, function, (module, str, or nonetype, str), (function, int)), nonetype), optional) \u2014 Frames to be ignored in order to reach the N th frame. These frames will not be counted to skip within that N-1 frames. You can specify: - A module (or filename of a module). Any calls from it and its submodules will be ignored. - A function. If it looks like it might be a decorated function, a MaybeDecoratedFunctionWarning will be shown. - Tuple of a function and a number of additional frames that should be skipped just before reaching this function in the stack. This is typically used for functions that have been decorated with a 'classic' decorator that replaces the function with a wrapper. In that case each such decorator involved should be counted in the number that's the second element of the tuple. - Tuple of a module (or filename) and qualified name (qualname). You can use Unix shell-style wildcards to match the qualname. Otherwise the qualname must appear exactly once in the module/file. By default, all calls from varname package, python standard libraries and lambda functions are ignored. multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS). If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a VarnameRetrievingError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failed to retrieve the name. Returns (Union(str, (str or tuple), nonetype)) The variable name, or None when raise_exc is False and we failed to retrieve the variable name. A tuple or a hierarchy (tuple of tuples) of variable names when multi_vars is True . Raises UserWarning \u2014 When there are multiple target in the assign node. (e.g: a = b = func() , in such a case, b == 'a' , may not be the case you want) VarnameRetrievingError \u2014 When there is invalid variables or invalid number of variables used on the LHS; or when we are unable to retrieve the variable name and raise_exc is set to True . function","title":"varname.core.varname"},{"location":"api/varname.core/#varnamecorewill","text":"</> Detect the attribute name right immediately after a function call. Examples >>> class AwesomeClass : >>> def __init__ ( self ): >>> self . will = None >>> def permit ( self ): >>> self . will = will () >>> if self . will == 'do' : >>> # let self handle do >>> return self >>> raise AttributeError ( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do ( self ): >>> if self . will != 'do' : >>> raise AttributeError ( \"You don't have permission to do\" ) >>> return 'I am doing!' >>> awesome = AwesomeClass () >>> # AttributeError: You don't have permission to do >>> awesome . do () >>> # AttributeError: Should do something with AwesomeClass object >>> awesome . permit () >>> awesome . permit () . do () == 'I am doing!' Parameters frame (int, optional) \u2014 At which frame this function is called. raise_exc (bool, optional) \u2014 Raise exception we failed to detect Returns (str, optional) The attribute name right after the function call If there is no attribute attached and raise_exc is False Raises VarnameRetrievingError \u2014 When raise_exc is True and we failed to detect the attribute name (including not having one) function","title":"varname.core.will"},{"location":"api/varname.core/#varnamecorenameof","text":"</> Get the names of the variables passed in Examples >>> a = 1 >>> nameof ( a ) # 'a' >>> b = 2 >>> nameof ( a , b ) # ('a', 'b') >>> x = lambda : None >>> x . y = 1 >>> nameof ( x . y , full = True ) # 'x.y' Note This function works with the environments where source code is available, in other words, the callee's node can be retrieved by executing . In some cases, for example, running code from python shell/REPL or from exec / eval , we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Parameters var \u2014 The variable to retrieve the name of *more_vars \u2014 Other variables to retrieve the names of frame (int, optional) \u2014 The depth of the frame (this function) is called. This is useful if you want to wrap this function. Note that the calls from varname and builtin modules are ignored. full (bool, optional) \u2014 Whether report the full path of the variable. For example: nameof(a.b.c, full=True) give you a.b.c instead of c Returns (str or (str)) The names of variables passed in. If a single varialble is passed, return the name of it. If multiple variables are passed, return a tuple of their names. Raises VarnameRetrievingError \u2014 When the callee's node cannot be retrieved or trying to retrieve the full name of non attribute series calls.","title":"varname.core.nameof"},{"location":"api/varname.helpers/","text":"module varname . helpers </> Some helper functions builtin based upon core features Classes Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr ) \u2014 Print variable names and values. </> register ( cls_or_func , frame , ignore , multi_vars , raise_exc ) (Union(type, callable(type: type))) \u2014 A decorator to register varname to a class or function </> function varname.helpers . register ( cls_or_func=None , frame=1 , ignore=None , multi_vars=False , raise_exc=True ) </> A decorator to register varname to a class or function When registered to a class, it can be accessed by self.__varname__ ; while to a function, it is registered to globals, meaning that it can be accessed directly. Parameters frame (int, optional) \u2014 The call stack index, indicating where this class is instantiated relative to where the variable is finally retrieved multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS). If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a VarnameRetrievingError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failed to retrieve the name. Examples >>> @varname . register >>> class Foo : pass >>> foo = Foo () >>> # foo.__varname__ == 'foo' >>> >>> @varname . register >>> def func (): >>> return __varname__ >>> foo = func () # foo == 'foo' Returns (Union(type, callable(type: type))) The wrapper function or the class/function itself if it is specified explictly. class varname.helpers . Wrapper ( value , frame=1 , ignore=None , raise_exc=True ) </> A wrapper with ability to retrieve the variable name Examples >>> foo = Wrapper ( True ) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper ( val ) >>> # bar.name == 'bar' >>> # bar.value is val Parameters value (any) \u2014 The value to be wrapped raise_exc (bool, optional) \u2014 Whether to raise exception when varname is failed to retrieve Attributes name \u2014 The variable name to which the instance is assigned value \u2014 The value this wrapper wraps function varname.helpers . debug ( var , *more_vars , prefix='DEBUG: ' , merge=False , repr=True ) </> Print variable names and values. Examples >>> a = 1 >>> b = object >>> print ( f 'a= { a } ' ) # previously, we have to do >>> print ( f ' { a =} ' ) # or with python3.8 >>> # instead we can do: >>> debug ( a ) # DEBUG: a=1 >>> debug ( a , prefix = '' ) # a=1 >>> debug ( a , b , merge = True ) # a=1, b=<object object at 0x2b9a4c89cf00> Parameters var \u2014 The variable to print *more_vars \u2014 Other variables to print prefix (str, optional) \u2014 A prefix to print for each line merge (bool, optional) \u2014 Whether merge all variables in one line or not repr (bool, optional) \u2014 Print the value as repr(var) ? otherwise str(var)","title":"varname.helpers"},{"location":"api/varname.helpers/#varnamehelpers","text":"</> Some helper functions builtin based upon core features Classes Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr ) \u2014 Print variable names and values. </> register ( cls_or_func , frame , ignore , multi_vars , raise_exc ) (Union(type, callable(type: type))) \u2014 A decorator to register varname to a class or function </> function","title":"varname.helpers"},{"location":"api/varname.helpers/#varnamehelpersregister","text":"</> A decorator to register varname to a class or function When registered to a class, it can be accessed by self.__varname__ ; while to a function, it is registered to globals, meaning that it can be accessed directly. Parameters frame (int, optional) \u2014 The call stack index, indicating where this class is instantiated relative to where the variable is finally retrieved multi_vars (bool, optional) \u2014 Whether allow multiple variables on left-hand side (LHS). If True , this function returns a tuple of the variable names, even there is only one variable on LHS. If False , and multiple variables on LHS, a VarnameRetrievingError will be raised. raise_exc (bool, optional) \u2014 Whether we should raise an exception if failed to retrieve the name. Examples >>> @varname . register >>> class Foo : pass >>> foo = Foo () >>> # foo.__varname__ == 'foo' >>> >>> @varname . register >>> def func (): >>> return __varname__ >>> foo = func () # foo == 'foo' Returns (Union(type, callable(type: type))) The wrapper function or the class/function itself if it is specified explictly. class","title":"varname.helpers.register"},{"location":"api/varname.helpers/#varnamehelperswrapper","text":"</> A wrapper with ability to retrieve the variable name Examples >>> foo = Wrapper ( True ) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper ( val ) >>> # bar.name == 'bar' >>> # bar.value is val Parameters value (any) \u2014 The value to be wrapped raise_exc (bool, optional) \u2014 Whether to raise exception when varname is failed to retrieve Attributes name \u2014 The variable name to which the instance is assigned value \u2014 The value this wrapper wraps function","title":"varname.helpers.Wrapper"},{"location":"api/varname.helpers/#varnamehelpersdebug","text":"</> Print variable names and values. Examples >>> a = 1 >>> b = object >>> print ( f 'a= { a } ' ) # previously, we have to do >>> print ( f ' { a =} ' ) # or with python3.8 >>> # instead we can do: >>> debug ( a ) # DEBUG: a=1 >>> debug ( a , prefix = '' ) # a=1 >>> debug ( a , b , merge = True ) # a=1, b=<object object at 0x2b9a4c89cf00> Parameters var \u2014 The variable to print *more_vars \u2014 Other variables to print prefix (str, optional) \u2014 A prefix to print for each line merge (bool, optional) \u2014 Whether merge all variables in one line or not repr (bool, optional) \u2014 Print the value as repr(var) ? otherwise str(var)","title":"varname.helpers.debug"},{"location":"api/varname.ignore/","text":"module varname . ignore </> The frame ignoring system for varname There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame. Ignore frames by a given module. Any calls inside it and inside its submodules will be ignored. A filename (path) to a module is also acceptable and recommended when code is executed by exec without module available. Ignore frames by a given pair of module and a qualified name (qualname). See 1) for acceptable modules. The qualname should be unique in that module. Ignore frames by a (non-decorated) function. Ignore frames by a decorated function. In this case, you can specified a tuple with the function and the number of decorators of it. The decorators on the wrapper function inside the decorators should also be counted. Any frames in varname , standard libraries, and frames of any expressions like are ignored by default. Classes IgnoreElem ( ) \u2014 An element of the ignore list </> IgnoreModule \u2014 Ignore calls from a module or its submodules </> IgnoreFilename \u2014 Ignore calls from a module by matching its filename </> IgnoreDirname \u2014 Ignore calls from modules inside a directory </> IgnoreFunction \u2014 Ignore a non-decorated function </> IgnoreDecorated \u2014 Ignore a decorated function </> IgnoreModuleQualname \u2014 Ignore calls by qualified name in the module </> IgnoreFilenameQualname \u2014 Ignore calls with given qualname in the module with the filename </> IgnoreOnlyQualname \u2014 Ignore calls that match the given qualname, across all frames. </> IgnoreList \u2014 The ignore list to match the frames to see if they should be ignored </> Functions create_ignore_elem ( ignore_elem ) ( IgnoreElem ) \u2014 Create an ignore element according to the type </> abstract class varname.ignore . IgnoreElem ( ) </> An element of the ignore list Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses abstract method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element method __repr__ ( ) \u2192 str </> Representation of the element class varname.ignore . IgnoreModule ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls from a module or its submodules Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreFilename ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls from a module by matching its filename Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreDirname ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls from modules inside a directory Currently used internally to ignore calls from standard libraries. Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreFunction ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore a non-decorated function Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreDecorated ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore a decorated function Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreModuleQualname ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls by qualified name in the module Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreFilenameQualname ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls with given qualname in the module with the filename Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element class varname.ignore . IgnoreOnlyQualname ( *ign_args ) </> Bases varname.ignore.IgnoreElem Ignore calls that match the given qualname, across all frames. Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod __init_subclass__ ( attrs ) </> Define different attributes for subclasses method subclass_init ( *ign_args ) </> init function for subclasses method __repr__ ( ) \u2192 str </> Representation of the element method match ( frame_no , frameinfos ) \u2192 bool </> Whether the frame matches the ignore element function varname.ignore . create_ignore_elem ( ignore_elem ) \u2192 IgnoreElem </> Create an ignore element according to the type class varname.ignore . IgnoreList ( ignore_list ) </> The ignore list to match the frames to see if they should be ignored Methods create ( ignore ) ( IgnoreList ) \u2014 Create an IgnoreList object </> get_frame ( frame_no ) (frame) \u2014 Get the right frame by the frame number </> nextframe_to_check ( frame_no , frameinfos ) (int) \u2014 Find the next frame to check </> classmethod create ( ignore ) </> Create an IgnoreList object Parameters ignore (Union(module, str, function, (module, str, or nonetype, str), (function, int), list of union(module, str, function, (module, str, or nonetype, str), (function, int)), nonetype)) \u2014 An element of the ignore list, either A module (or filename of a module) A tuple of module (or filename) and qualified name A function A tuple of function and number of decorators Returns ( IgnoreList ) The IgnoreList object method nextframe_to_check ( frame_no , frameinfos ) </> Find the next frame to check In modst cases, the next frame to check is the next adjacent frame. But for IgnoreDecorated, the next frame to check should be the next ignore[1] th frame. Parameters frame_no (int) \u2014 The index of current frame to check frameinfos (list of FrameInfo) \u2014 The frame info objects Returns (int) A number for Next N th frame to check. 0 if no frame matched. method get_frame ( frame_no ) </> Get the right frame by the frame number Parameters frame_no (int) \u2014 The index of the frame to get Returns (frame) The desired frame Raises VarnameRetrievingError \u2014 if any exceptions raised during the process.","title":"varname.ignore"},{"location":"api/varname.ignore/#varnameignore","text":"</> The frame ignoring system for varname There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame. Ignore frames by a given module. Any calls inside it and inside its submodules will be ignored. A filename (path) to a module is also acceptable and recommended when code is executed by exec without module available. Ignore frames by a given pair of module and a qualified name (qualname). See 1) for acceptable modules. The qualname should be unique in that module. Ignore frames by a (non-decorated) function. Ignore frames by a decorated function. In this case, you can specified a tuple with the function and the number of decorators of it. The decorators on the wrapper function inside the decorators should also be counted. Any frames in varname , standard libraries, and frames of any expressions like are ignored by default. Classes IgnoreElem ( ) \u2014 An element of the ignore list </> IgnoreModule \u2014 Ignore calls from a module or its submodules </> IgnoreFilename \u2014 Ignore calls from a module by matching its filename </> IgnoreDirname \u2014 Ignore calls from modules inside a directory </> IgnoreFunction \u2014 Ignore a non-decorated function </> IgnoreDecorated \u2014 Ignore a decorated function </> IgnoreModuleQualname \u2014 Ignore calls by qualified name in the module </> IgnoreFilenameQualname \u2014 Ignore calls with given qualname in the module with the filename </> IgnoreOnlyQualname \u2014 Ignore calls that match the given qualname, across all frames. </> IgnoreList \u2014 The ignore list to match the frames to see if they should be ignored </> Functions create_ignore_elem ( ignore_elem ) ( IgnoreElem ) \u2014 Create an ignore element according to the type </> abstract class","title":"varname.ignore"},{"location":"api/varname.ignore/#varnameignoreignoreelem","text":"</> An element of the ignore list Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> classmethod","title":"varname.ignore.IgnoreElem"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass","text":"</> Define different attributes for subclasses abstract method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreelemmatch","text":"</> Whether the frame matches the ignore element method","title":"varname.ignore.IgnoreElem.match"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr","text":"</> Representation of the element class","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoremodule","text":"</> Bases varname.ignore.IgnoreElem Ignore calls from a module or its submodules Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreModule"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_1","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_1","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoremodulematch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreModule.match"},{"location":"api/varname.ignore/#varnameignoreignorefilename","text":"</> Bases varname.ignore.IgnoreElem Ignore calls from a module by matching its filename Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreFilename"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_2","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_1","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_2","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignorefilenamematch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreFilename.match"},{"location":"api/varname.ignore/#varnameignoreignoredirname","text":"</> Bases varname.ignore.IgnoreElem Ignore calls from modules inside a directory Currently used internally to ignore calls from standard libraries. Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreDirname"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_3","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_2","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_3","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoredirnamematch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreDirname.match"},{"location":"api/varname.ignore/#varnameignoreignorefunction","text":"</> Bases varname.ignore.IgnoreElem Ignore a non-decorated function Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreFunction"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_4","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_3","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_4","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignorefunctionmatch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreFunction.match"},{"location":"api/varname.ignore/#varnameignoreignoredecorated","text":"</> Bases varname.ignore.IgnoreElem Ignore a decorated function Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreDecorated"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_5","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_4","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_5","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoredecoratedmatch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreDecorated.match"},{"location":"api/varname.ignore/#varnameignoreignoremodulequalname","text":"</> Bases varname.ignore.IgnoreElem Ignore calls by qualified name in the module Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreModuleQualname"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_6","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_5","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_6","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoremodulequalnamematch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreModuleQualname.match"},{"location":"api/varname.ignore/#varnameignoreignorefilenamequalname","text":"</> Bases varname.ignore.IgnoreElem Ignore calls with given qualname in the module with the filename Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreFilenameQualname"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_7","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_6","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_7","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignorefilenamequalnamematch","text":"</> Whether the frame matches the ignore element class","title":"varname.ignore.IgnoreFilenameQualname.match"},{"location":"api/varname.ignore/#varnameignoreignoreonlyqualname","text":"</> Bases varname.ignore.IgnoreElem Ignore calls that match the given qualname, across all frames. Methods __init_subclass__ ( attrs ) \u2014 Define different attributes for subclasses </> __repr__ ( ) (str) \u2014 Representation of the element </> match ( frame_no , frameinfos ) (bool) \u2014 Whether the frame matches the ignore element </> subclass_init ( *ign_args ) \u2014 init function for subclasses </> classmethod","title":"varname.ignore.IgnoreOnlyQualname"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclass_8","text":"</> Define different attributes for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass"},{"location":"api/varname.ignore/#varnameignoreignoreeleminit_subclasssubclass_init_7","text":"</> init function for subclasses method","title":"varname.ignore.IgnoreElem.init_subclass..subclass_init"},{"location":"api/varname.ignore/#varnameignoreignoreelemrepr_8","text":"</> Representation of the element method","title":"varname.ignore.IgnoreElem.repr"},{"location":"api/varname.ignore/#varnameignoreignoreonlyqualnamematch","text":"</> Whether the frame matches the ignore element function","title":"varname.ignore.IgnoreOnlyQualname.match"},{"location":"api/varname.ignore/#varnameignorecreate_ignore_elem","text":"</> Create an ignore element according to the type class","title":"varname.ignore.create_ignore_elem"},{"location":"api/varname.ignore/#varnameignoreignorelist","text":"</> The ignore list to match the frames to see if they should be ignored Methods create ( ignore ) ( IgnoreList ) \u2014 Create an IgnoreList object </> get_frame ( frame_no ) (frame) \u2014 Get the right frame by the frame number </> nextframe_to_check ( frame_no , frameinfos ) (int) \u2014 Find the next frame to check </> classmethod","title":"varname.ignore.IgnoreList"},{"location":"api/varname.ignore/#varnameignoreignorelistcreate","text":"</> Create an IgnoreList object Parameters ignore (Union(module, str, function, (module, str, or nonetype, str), (function, int), list of union(module, str, function, (module, str, or nonetype, str), (function, int)), nonetype)) \u2014 An element of the ignore list, either A module (or filename of a module) A tuple of module (or filename) and qualified name A function A tuple of function and number of decorators Returns ( IgnoreList ) The IgnoreList object method","title":"varname.ignore.IgnoreList.create"},{"location":"api/varname.ignore/#varnameignoreignorelistnextframe_to_check","text":"</> Find the next frame to check In modst cases, the next frame to check is the next adjacent frame. But for IgnoreDecorated, the next frame to check should be the next ignore[1] th frame. Parameters frame_no (int) \u2014 The index of current frame to check frameinfos (list of FrameInfo) \u2014 The frame info objects Returns (int) A number for Next N th frame to check. 0 if no frame matched. method","title":"varname.ignore.IgnoreList.nextframe_to_check"},{"location":"api/varname.ignore/#varnameignoreignorelistget_frame","text":"</> Get the right frame by the frame number Parameters frame_no (int) \u2014 The index of the frame to get Returns (frame) The desired frame Raises VarnameRetrievingError \u2014 if any exceptions raised during the process.","title":"varname.ignore.IgnoreList.get_frame"},{"location":"api/varname/","text":"package varname </> Dark magics about variable names in python module varname . core </> Provide core features for varname Functions nameof ( var , *more_vars , frame , full ) (str or (str)) \u2014 Get the names of the variables passed in </> varname ( frame , ignore , multi_vars , raise_exc ) (Union(str, (str or tuple), nonetype)) \u2014 Get the name of the variable(s) that assigned by function call or class instantiation. </> will ( frame , raise_exc ) (str, optional) \u2014 Detect the attribute name right immediately after a function call. </> module varname . ignore </> The frame ignoring system for varname There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame. Ignore frames by a given module. Any calls inside it and inside its submodules will be ignored. A filename (path) to a module is also acceptable and recommended when code is executed by exec without module available. Ignore frames by a given pair of module and a qualified name (qualname). See 1) for acceptable modules. The qualname should be unique in that module. Ignore frames by a (non-decorated) function. Ignore frames by a decorated function. In this case, you can specified a tuple with the function and the number of decorators of it. The decorators on the wrapper function inside the decorators should also be counted. Any frames in varname , standard libraries, and frames of any expressions like are ignored by default. Classes IgnoreElem ( ) \u2014 An element of the ignore list </> IgnoreModule \u2014 Ignore calls from a module or its submodules </> IgnoreFilename \u2014 Ignore calls from a module by matching its filename </> IgnoreDirname \u2014 Ignore calls from modules inside a directory </> IgnoreFunction \u2014 Ignore a non-decorated function </> IgnoreDecorated \u2014 Ignore a decorated function </> IgnoreModuleQualname \u2014 Ignore calls by qualified name in the module </> IgnoreFilenameQualname \u2014 Ignore calls with given qualname in the module with the filename </> IgnoreOnlyQualname \u2014 Ignore calls that match the given qualname, across all frames. </> IgnoreList \u2014 The ignore list to match the frames to see if they should be ignored </> Functions create_ignore_elem ( ignore_elem ) ( IgnoreElem ) \u2014 Create an ignore element according to the type </> module varname . helpers </> Some helper functions builtin based upon core features Classes Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr ) \u2014 Print variable names and values. </> register ( cls_or_func , frame , ignore , multi_vars , raise_exc ) (Union(type, callable(type: type))) \u2014 A decorator to register varname to a class or function </> module varname . utils </> Some internal utilities for varname Classes config \u2014 Global configurations for varname </> VarnameRetrievingError \u2014 When failed to retrieve the varname </> QualnameNonUniqueError \u2014 When a qualified name is used as an ignore element but references to multiple objects in a module </> MaybeDecoratedFunctionWarning \u2014 When a suspecious decorated function used as ignore function directly </> MultiTargetAssignmentWarning \u2014 When varname tries to retrieve variable name in a multi-target assignment </> Functions attach_ignore_id_to_module ( module ) \u2014 Attach the ignore id to module </> bytecode_nameof ( frame ) (str) \u2014 Bytecode version of nameof as a fallback </> cached_getmodule ( codeobj ) \u2014 Cached version of inspect.getmodule </> check_qualname_by_source ( source , modname , qualname ) \u2014 Check if a qualname in module is unique </> debug_ignore_frame ( msg , frameinfo ) \u2014 Print the debug message for a given frame info object </> frame_matches_module_by_ignore_id ( frame , module ) (bool) \u2014 Check if the frame is from the module by ignore id </> get_node ( frame , ignore , raise_exc ) (AST, optional) \u2014 Try to get node from the executing object. </> lookfor_parent_assign ( node ) (Assign, optional) \u2014 Look for an ast.Assign node in the parents </> node_name ( node ) (Union(str, (str or tuple), nonetype)) \u2014 Get the node node name. </>","title":"API"},{"location":"api/varname/#varname","text":"</> Dark magics about variable names in python module","title":"varname"},{"location":"api/varname/#varnamecore","text":"</> Provide core features for varname Functions nameof ( var , *more_vars , frame , full ) (str or (str)) \u2014 Get the names of the variables passed in </> varname ( frame , ignore , multi_vars , raise_exc ) (Union(str, (str or tuple), nonetype)) \u2014 Get the name of the variable(s) that assigned by function call or class instantiation. </> will ( frame , raise_exc ) (str, optional) \u2014 Detect the attribute name right immediately after a function call. </> module","title":"varname.core"},{"location":"api/varname/#varnameignore","text":"</> The frame ignoring system for varname There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame. Ignore frames by a given module. Any calls inside it and inside its submodules will be ignored. A filename (path) to a module is also acceptable and recommended when code is executed by exec without module available. Ignore frames by a given pair of module and a qualified name (qualname). See 1) for acceptable modules. The qualname should be unique in that module. Ignore frames by a (non-decorated) function. Ignore frames by a decorated function. In this case, you can specified a tuple with the function and the number of decorators of it. The decorators on the wrapper function inside the decorators should also be counted. Any frames in varname , standard libraries, and frames of any expressions like are ignored by default. Classes IgnoreElem ( ) \u2014 An element of the ignore list </> IgnoreModule \u2014 Ignore calls from a module or its submodules </> IgnoreFilename \u2014 Ignore calls from a module by matching its filename </> IgnoreDirname \u2014 Ignore calls from modules inside a directory </> IgnoreFunction \u2014 Ignore a non-decorated function </> IgnoreDecorated \u2014 Ignore a decorated function </> IgnoreModuleQualname \u2014 Ignore calls by qualified name in the module </> IgnoreFilenameQualname \u2014 Ignore calls with given qualname in the module with the filename </> IgnoreOnlyQualname \u2014 Ignore calls that match the given qualname, across all frames. </> IgnoreList \u2014 The ignore list to match the frames to see if they should be ignored </> Functions create_ignore_elem ( ignore_elem ) ( IgnoreElem ) \u2014 Create an ignore element according to the type </> module","title":"varname.ignore"},{"location":"api/varname/#varnamehelpers","text":"</> Some helper functions builtin based upon core features Classes Wrapper \u2014 A wrapper with ability to retrieve the variable name </> Functions debug ( var , *more_vars , prefix , merge , repr ) \u2014 Print variable names and values. </> register ( cls_or_func , frame , ignore , multi_vars , raise_exc ) (Union(type, callable(type: type))) \u2014 A decorator to register varname to a class or function </> module","title":"varname.helpers"},{"location":"api/varname/#varnameutils","text":"</> Some internal utilities for varname Classes config \u2014 Global configurations for varname </> VarnameRetrievingError \u2014 When failed to retrieve the varname </> QualnameNonUniqueError \u2014 When a qualified name is used as an ignore element but references to multiple objects in a module </> MaybeDecoratedFunctionWarning \u2014 When a suspecious decorated function used as ignore function directly </> MultiTargetAssignmentWarning \u2014 When varname tries to retrieve variable name in a multi-target assignment </> Functions attach_ignore_id_to_module ( module ) \u2014 Attach the ignore id to module </> bytecode_nameof ( frame ) (str) \u2014 Bytecode version of nameof as a fallback </> cached_getmodule ( codeobj ) \u2014 Cached version of inspect.getmodule </> check_qualname_by_source ( source , modname , qualname ) \u2014 Check if a qualname in module is unique </> debug_ignore_frame ( msg , frameinfo ) \u2014 Print the debug message for a given frame info object </> frame_matches_module_by_ignore_id ( frame , module ) (bool) \u2014 Check if the frame is from the module by ignore id </> get_node ( frame , ignore , raise_exc ) (AST, optional) \u2014 Try to get node from the executing object. </> lookfor_parent_assign ( node ) (Assign, optional) \u2014 Look for an ast.Assign node in the parents </> node_name ( node ) (Union(str, (str or tuple), nonetype)) \u2014 Get the node node name. </>","title":"varname.utils"},{"location":"api/varname.utils/","text":"module varname . utils </> Some internal utilities for varname Classes config \u2014 Global configurations for varname </> VarnameRetrievingError \u2014 When failed to retrieve the varname </> QualnameNonUniqueError \u2014 When a qualified name is used as an ignore element but references to multiple objects in a module </> MaybeDecoratedFunctionWarning \u2014 When a suspecious decorated function used as ignore function directly </> MultiTargetAssignmentWarning \u2014 When varname tries to retrieve variable name in a multi-target assignment </> Functions attach_ignore_id_to_module ( module ) \u2014 Attach the ignore id to module </> bytecode_nameof ( frame ) (str) \u2014 Bytecode version of nameof as a fallback </> cached_getmodule ( codeobj ) \u2014 Cached version of inspect.getmodule </> check_qualname_by_source ( source , modname , qualname ) \u2014 Check if a qualname in module is unique </> debug_ignore_frame ( msg , frameinfo ) \u2014 Print the debug message for a given frame info object </> frame_matches_module_by_ignore_id ( frame , module ) (bool) \u2014 Check if the frame is from the module by ignore id </> get_node ( frame , ignore , raise_exc ) (AST, optional) \u2014 Try to get node from the executing object. </> lookfor_parent_assign ( node ) (Assign, optional) \u2014 Look for an ast.Assign node in the parents </> node_name ( node ) (Union(str, (str or tuple), nonetype)) \u2014 Get the node node name. </> class varname.utils . config ( ) </> Global configurations for varname class varname.utils . VarnameRetrievingError ( ) </> Bases Exception BaseException When failed to retrieve the varname class varname.utils . QualnameNonUniqueError ( ) </> Bases Exception BaseException When a qualified name is used as an ignore element but references to multiple objects in a module class varname.utils . MaybeDecoratedFunctionWarning ( ) </> Bases Warning Exception BaseException When a suspecious decorated function used as ignore function directly class varname.utils . MultiTargetAssignmentWarning ( ) </> Bases Warning Exception BaseException When varname tries to retrieve variable name in a multi-target assignment function varname.utils . cached_getmodule ( codeobj ) </> Cached version of inspect.getmodule function varname.utils . get_node ( frame , ignore=None , raise_exc=True ) \u2192 AST, optional </> Try to get node from the executing object. This can fail when a frame is failed to retrieve. One case should be when python code is executed in R pacakge reticulate , where only first frame is kept. When the node can not be retrieved, try to return the first statement. function varname.utils . lookfor_parent_assign ( node ) \u2192 Assign, optional </> Look for an ast.Assign node in the parents function varname.utils . node_name ( node ) \u2192 Union(str, (str or tuple), nonetype) </> Get the node node name. Raises VarnameRetrievingError when failed function varname.utils . bytecode_nameof ( frame=1 ) \u2192 str </> Bytecode version of nameof as a fallback function varname.utils . attach_ignore_id_to_module ( module ) </> Attach the ignore id to module This is useful when a module cannot be retrieved by frames using inspect.getmodule , then we can use this id, which will exist in frame.f_globals to check if the module matches in ignore. Do it only when the file is not avaiable or does not exist for the module. Since this probably means the source is not avaiable and inspect.getmodule would not work function varname.utils . frame_matches_module_by_ignore_id ( frame , module ) \u2192 bool </> Check if the frame is from the module by ignore id function varname.utils . check_qualname_by_source ( source , modname , qualname ) </> Check if a qualname in module is unique function varname.utils . debug_ignore_frame ( msg , frameinfo=None ) </> Print the debug message for a given frame info object Parameters msg (str) \u2014 The debugging message frameinfo (FrameInfo, optional) \u2014 The FrameInfo object for the frame","title":"varname.utils"},{"location":"api/varname.utils/#varnameutils","text":"</> Some internal utilities for varname Classes config \u2014 Global configurations for varname </> VarnameRetrievingError \u2014 When failed to retrieve the varname </> QualnameNonUniqueError \u2014 When a qualified name is used as an ignore element but references to multiple objects in a module </> MaybeDecoratedFunctionWarning \u2014 When a suspecious decorated function used as ignore function directly </> MultiTargetAssignmentWarning \u2014 When varname tries to retrieve variable name in a multi-target assignment </> Functions attach_ignore_id_to_module ( module ) \u2014 Attach the ignore id to module </> bytecode_nameof ( frame ) (str) \u2014 Bytecode version of nameof as a fallback </> cached_getmodule ( codeobj ) \u2014 Cached version of inspect.getmodule </> check_qualname_by_source ( source , modname , qualname ) \u2014 Check if a qualname in module is unique </> debug_ignore_frame ( msg , frameinfo ) \u2014 Print the debug message for a given frame info object </> frame_matches_module_by_ignore_id ( frame , module ) (bool) \u2014 Check if the frame is from the module by ignore id </> get_node ( frame , ignore , raise_exc ) (AST, optional) \u2014 Try to get node from the executing object. </> lookfor_parent_assign ( node ) (Assign, optional) \u2014 Look for an ast.Assign node in the parents </> node_name ( node ) (Union(str, (str or tuple), nonetype)) \u2014 Get the node node name. </> class","title":"varname.utils"},{"location":"api/varname.utils/#varnameutilsconfig","text":"</> Global configurations for varname class","title":"varname.utils.config"},{"location":"api/varname.utils/#varnameutilsvarnameretrievingerror","text":"</> Bases Exception BaseException When failed to retrieve the varname class","title":"varname.utils.VarnameRetrievingError"},{"location":"api/varname.utils/#varnameutilsqualnamenonuniqueerror","text":"</> Bases Exception BaseException When a qualified name is used as an ignore element but references to multiple objects in a module class","title":"varname.utils.QualnameNonUniqueError"},{"location":"api/varname.utils/#varnameutilsmaybedecoratedfunctionwarning","text":"</> Bases Warning Exception BaseException When a suspecious decorated function used as ignore function directly class","title":"varname.utils.MaybeDecoratedFunctionWarning"},{"location":"api/varname.utils/#varnameutilsmultitargetassignmentwarning","text":"</> Bases Warning Exception BaseException When varname tries to retrieve variable name in a multi-target assignment function","title":"varname.utils.MultiTargetAssignmentWarning"},{"location":"api/varname.utils/#varnameutilscached_getmodule","text":"</> Cached version of inspect.getmodule function","title":"varname.utils.cached_getmodule"},{"location":"api/varname.utils/#varnameutilsget_node","text":"</> Try to get node from the executing object. This can fail when a frame is failed to retrieve. One case should be when python code is executed in R pacakge reticulate , where only first frame is kept. When the node can not be retrieved, try to return the first statement. function","title":"varname.utils.get_node"},{"location":"api/varname.utils/#varnameutilslookfor_parent_assign","text":"</> Look for an ast.Assign node in the parents function","title":"varname.utils.lookfor_parent_assign"},{"location":"api/varname.utils/#varnameutilsnode_name","text":"</> Get the node node name. Raises VarnameRetrievingError when failed function","title":"varname.utils.node_name"},{"location":"api/varname.utils/#varnameutilsbytecode_nameof","text":"</> Bytecode version of nameof as a fallback function","title":"varname.utils.bytecode_nameof"},{"location":"api/varname.utils/#varnameutilsattach_ignore_id_to_module","text":"</> Attach the ignore id to module This is useful when a module cannot be retrieved by frames using inspect.getmodule , then we can use this id, which will exist in frame.f_globals to check if the module matches in ignore. Do it only when the file is not avaiable or does not exist for the module. Since this probably means the source is not avaiable and inspect.getmodule would not work function","title":"varname.utils.attach_ignore_id_to_module"},{"location":"api/varname.utils/#varnameutilsframe_matches_module_by_ignore_id","text":"</> Check if the frame is from the module by ignore id function","title":"varname.utils.frame_matches_module_by_ignore_id"},{"location":"api/varname.utils/#varnameutilscheck_qualname_by_source","text":"</> Check if a qualname in module is unique function","title":"varname.utils.check_qualname_by_source"},{"location":"api/varname.utils/#varnameutilsdebug_ignore_frame","text":"</> Print the debug message for a given frame info object Parameters msg (str) \u2014 The debugging message frameinfo (FrameInfo, optional) \u2014 The FrameInfo object for the frame","title":"varname.utils.debug_ignore_frame"},{"location":"api/source/varname.core/","text":"SOURCE CODE varname. core DOCS \"\"\"Provide core features for varname\"\"\" import ast import warnings from typing import Optional , Tuple , Union from .utils import ( bytecode_nameof , get_node , lookfor_parent_assign , node_name , VarnameRetrievingError , MultiTargetAssignmentWarning ) from .ignore import IgnoreList , IgnoreType def varname ( DOCS frame : int = 1 , ignore : Optional [ IgnoreType ] = None , multi_vars : bool = False , raise_exc : bool = True ) -> Optional [ Union [ str , Tuple [ Union [ str , tuple ]]]]: \"\"\"Get the name of the variable(s) that assigned by function call or class instantiation. To debug and specify the right frame and ignore arguments, you can set debug on and see how the frames are ignored or selected: >>> from varname import config >>> config.debug = True Args: frame: `N`th frame used to retrieve the variable name. This means `N-1` intermediate frames will be skipped. Note that the frames match `ignore` will not be counted. See `ignore` for details. ignore: Frames to be ignored in order to reach the `N`th frame. These frames will not be counted to skip within that `N-1` frames. You can specify: - A module (or filename of a module). Any calls from it and its submodules will be ignored. - A function. If it looks like it might be a decorated function, a `MaybeDecoratedFunctionWarning` will be shown. - Tuple of a function and a number of additional frames that should be skipped just before reaching this function in the stack. This is typically used for functions that have been decorated with a 'classic' decorator that replaces the function with a wrapper. In that case each such decorator involved should be counted in the number that's the second element of the tuple. - Tuple of a module (or filename) and qualified name (qualname). You can use Unix shell-style wildcards to match the qualname. Otherwise the qualname must appear exactly once in the module/file. By default, all calls from `varname` package, python standard libraries and lambda functions are ignored. multi_vars: Whether allow multiple variables on left-hand side (LHS). If `True`, this function returns a tuple of the variable names, even there is only one variable on LHS. If `False`, and multiple variables on LHS, a `VarnameRetrievingError` will be raised. raise_exc: Whether we should raise an exception if failed to retrieve the name. Returns: The variable name, or `None` when `raise_exc` is `False` and we failed to retrieve the variable name. A tuple or a hierarchy (tuple of tuples) of variable names when `multi_vars` is `True`. Raises: VarnameRetrievingError: When there is invalid variables or invalid number of variables used on the LHS; or when we are unable to retrieve the variable name and `raise_exc` is set to `True`. UserWarning: When there are multiple target in the assign node. (e.g: `a = b = func()`, in such a case, `b == 'a'`, may not be the case you want) \"\"\" # Skip one more frame, as it is supposed to be called # inside another function node = get_node ( frame + 1 , ignore , raise_exc = raise_exc ) if not node : if raise_exc : raise VarnameRetrievingError ( \"Unable to retrieve the ast node.\" ) return None node = lookfor_parent_assign ( node ) if not node : if raise_exc : raise VarnameRetrievingError ( 'Failed to retrieve the variable name.' ) return None if isinstance ( node , ast . AnnAssign ): target = node . target else : # Need to actually check that there's just one # give warnings if: a = b = func() if len ( node . targets ) > 1 : warnings . warn ( \"Multiple targets in assignment, variable name \" \"on the very left will be used.\" , MultiTargetAssignmentWarning ) target = node . targets [ 0 ] names = node_name ( target ) if not isinstance ( names , tuple ): names = ( names , ) if multi_vars : return names if len ( names ) > 1 : raise VarnameRetrievingError ( f \"Expect a single variable on left-hand side, got { len ( names ) } .\" ) return names [ 0 ] def will ( frame : int = 1 , raise_exc : bool = True ) -> Optional [ str ]: DOCS \"\"\"Detect the attribute name right immediately after a function call. Examples: >>> class AwesomeClass: >>> def __init__(self): >>> self.will = None >>> def permit(self): >>> self.will = will() >>> if self.will == 'do': >>> # let self handle do >>> return self >>> raise AttributeError( >>> 'Should do something with AwesomeClass object' >>> ) >>> def do(self): >>> if self.will != 'do': >>> raise AttributeError(\"You don't have permission to do\") >>> return 'I am doing!' >>> awesome = AwesomeClass() >>> # AttributeError: You don't have permission to do >>> awesome.do() >>> # AttributeError: Should do something with AwesomeClass object >>> awesome.permit() >>> awesome.permit().do() == 'I am doing!' Args: frame: At which frame this function is called. raise_exc: Raise exception we failed to detect Returns: The attribute name right after the function call If there is no attribute attached and `raise_exc` is `False` Raises: VarnameRetrievingError: When `raise_exc` is `True` and we failed to detect the attribute name (including not having one) \"\"\" node = get_node ( frame + 1 , raise_exc = raise_exc ) if not node : if raise_exc : raise VarnameRetrievingError ( \"Unable to retrieve the frame.\" ) return None # try to get node inst.attr from inst.attr() node = node . parent # see test_will_fail if not isinstance ( node , ast . Attribute ): if raise_exc : raise VarnameRetrievingError ( \"Function `will` has to be called within \" \"a method/property of a class.\" ) return None # ast.Attribute return node . attr def nameof ( var , * more_vars , # pylint: disable=unused-argument DOCS frame : int = 1 , full : Optional [ bool ] = None ) -> Union [ str , Tuple [ str ]]: \"\"\"Get the names of the variables passed in Examples: >>> a = 1 >>> nameof(a) # 'a' >>> b = 2 >>> nameof(a, b) # ('a', 'b') >>> x = lambda: None >>> x.y = 1 >>> nameof(x.y, full=True) # 'x.y' Note: This function works with the environments where source code is available, in other words, the callee's node can be retrieved by `executing`. In some cases, for example, running code from python shell/REPL or from `exec`/`eval`, we try to fetch the variable name from the bytecode. This requires only a single variable name is passed to this function and no keyword arguments, meaning that getting full names of attribute calls are not supported in such cases. Args: var: The variable to retrieve the name of *more_vars: Other variables to retrieve the names of frame: The depth of the frame (this function) is called. This is useful if you want to wrap this function. Note that the calls from varname and builtin modules are ignored. full: Whether report the full path of the variable. For example: `nameof(a.b.c, full=True)` give you `a.b.c` instead of `c` Returns: The names of variables passed in. If a single varialble is passed, return the name of it. If multiple variables are passed, return a tuple of their names. Raises: VarnameRetrievingError: When the callee's node cannot be retrieved or trying to retrieve the full name of non attribute series calls. \"\"\" node = get_node ( frame , raise_exc = True ) if not node : # We can't retrieve the node by executing. # It can be due to running code from python/shell, exec/eval or # other environments where sourcecode cannot be reached # make sure we keep it simple (only single variable passed and no # full passed) to use _bytecode_nameof if not more_vars and full is None : return bytecode_nameof ( frame ) # We are anyway raising exceptions, no worries about additional burden # of frame retrieval again # may raise exception, just leave it as is frame = IgnoreList . create ( None ) . get_frame ( frame ) source = frame . f_code . co_filename if source == '<stdin>' : raise VarnameRetrievingError ( \"Are you trying to call nameof in REPL/python shell? \" \"In such a case, nameof can only be called with single \" \"argument and no keyword arguments.\" ) if source == '<string>' : raise VarnameRetrievingError ( \"Are you trying to call nameof from exec/eval? \" \"In such a case, nameof can only be called with single \" \"argument and no keyword arguments.\" ) raise VarnameRetrievingError ( \"Source code unavailable, nameof can only retrieve the name of \" \"a single variable, and argument `full` should not be specified.\" ) ret = [] for arg in node . args : if not full or isinstance ( arg , ast . Name ): ret . append ( node_name ( arg )) else : # traverse the node to get the full name: nameof(a.b.c) # arg: # Attribute(value=Attribute(value=Name(id='a', ctx=Load()), # attr='b', # ctx=Load()), # attr='c', # ctx=Load()) full_name = [] while not isinstance ( arg , ast . Name ): if not isinstance ( arg , ast . Attribute ): raise VarnameRetrievingError ( 'Can only retrieve full names of ' '(chained) attribute calls by nameof.' ) full_name . append ( arg . attr ) arg = arg . value # now it is an ast.Name full_name . append ( arg . id ) ret . append ( '.' . join ( reversed ( full_name ))) return ret [ 0 ] if not more_vars else tuple ( ret )","title":"varname.core"},{"location":"api/source/varname.helpers/","text":"SOURCE CODE varname. helpers DOCS \"\"\"Some helper functions builtin based upon core features\"\"\" import inspect from functools import partial , wraps from typing import Any , Callable , Optional , Union from .utils import IgnoreType from .core import nameof , varname def register ( DOCS cls_or_func : type = None , * , frame : int = 1 , ignore : Optional [ IgnoreType ] = None , multi_vars : bool = False , raise_exc : bool = True ) -> Union [ type , Callable [[ type ], type ]]: \"\"\"A decorator to register __varname__ to a class or function When registered to a class, it can be accessed by `self.__varname__`; while to a function, it is registered to globals, meaning that it can be accessed directly. Args: frame: The call stack index, indicating where this class is instantiated relative to where the variable is finally retrieved multi_vars: Whether allow multiple variables on left-hand side (LHS). If `True`, this function returns a tuple of the variable names, even there is only one variable on LHS. If `False`, and multiple variables on LHS, a `VarnameRetrievingError` will be raised. raise_exc: Whether we should raise an exception if failed to retrieve the name. Examples: >>> @varname.register >>> class Foo: pass >>> foo = Foo() >>> # foo.__varname__ == 'foo' >>> >>> @varname.register >>> def func(): >>> return __varname__ >>> foo = func() # foo == 'foo' Returns: The wrapper function or the class/function itself if it is specified explictly. \"\"\" if inspect . isclass ( cls_or_func ): orig_init = cls_or_func . __init__ @wraps ( cls_or_func . __init__ ) def wrapped_init ( self , * args , ** kwargs ): \"\"\"Wrapped init function to replace the original one\"\"\" self . __varname__ = varname ( frame - 1 , ignore = ignore , multi_vars = multi_vars , raise_exc = raise_exc ) orig_init ( self , * args , ** kwargs ) cls_or_func . __init__ = wrapped_init return cls_or_func if inspect . isfunction ( cls_or_func ): @wraps ( cls_or_func ) def wrapper ( * args , ** kwargs ): \"\"\"The wrapper to register `__varname__` to a function\"\"\" cls_or_func . __globals__ [ '__varname__' ] = varname ( frame - 1 , ignore = ignore , multi_vars = multi_vars , raise_exc = raise_exc ) try : return cls_or_func ( * args , ** kwargs ) finally : del cls_or_func . __globals__ [ '__varname__' ] return wrapper # None, meaning we have other arguments return partial ( register , frame = frame , ignore = ignore , multi_vars = multi_vars , raise_exc = raise_exc ) class Wrapper : DOCS \"\"\"A wrapper with ability to retrieve the variable name Examples: >>> foo = Wrapper(True) >>> # foo.name == 'foo' >>> # foo.value == True >>> val = {} >>> bar = Wrapper(val) >>> # bar.name == 'bar' >>> # bar.value is val Args: value: The value to be wrapped raise_exc: Whether to raise exception when varname is failed to retrieve Attributes: name: The variable name to which the instance is assigned value: The value this wrapper wraps \"\"\" def __init__ ( self , value : Any , frame : int = 1 , ignore : Optional [ IgnoreType ] = None , raise_exc : bool = True ): # This call is ignored, since it's inside varname self . name = varname ( frame - 1 , ignore = ignore , raise_exc = raise_exc ) self . value = value def __str__ ( self ) -> str : return repr ( self . value ) def __repr__ ( self ) -> str : return ( f \"< { self . __class__ . __name__ } \" f \"(name= { self . name !r} , value= { self . value !r} )>\" ) def debug ( var , * more_vars , DOCS prefix : str = 'DEBUG: ' , merge : bool = False , repr : bool = True ) -> None : # pylint: disable=redefined-builtin \"\"\"Print variable names and values. Examples: >>> a = 1 >>> b = object >>> print(f'a={a}') # previously, we have to do >>> print(f'{a=}') # or with python3.8 >>> # instead we can do: >>> debug(a) # DEBUG: a=1 >>> debug(a, prefix='') # a=1 >>> debug(a, b, merge=True) # a=1, b=<object object at 0x2b9a4c89cf00> Args: var: The variable to print *more_vars: Other variables to print prefix: A prefix to print for each line merge: Whether merge all variables in one line or not repr: Print the value as `repr(var)`? otherwise `str(var)` \"\"\" var_names = nameof ( var , * more_vars , full = True ) if not isinstance ( var_names , tuple ): var_names = ( var_names , ) variables = ( var , * more_vars ) name_and_values = [ f \" { var_name } = { variables [ i ] !r} \" if repr else f \" { var_name } = { variables [ i ] } \" for i , var_name in enumerate ( var_names )] if merge : print ( f \" { prefix }{ ', ' . join ( name_and_values ) } \" ) else : for name_and_value in name_and_values : print ( f \" { prefix }{ name_and_value } \" )","title":"varname.helpers"},{"location":"api/source/varname.ignore/","text":"SOURCE CODE varname. ignore DOCS \"\"\"The frame ignoring system for varname There 4 mechanisms to ignore intermediate frames to determine the desired one so that a variable name should be retrieved at that frame. 1. Ignore frames by a given module. Any calls inside it and inside its submodules will be ignored. A filename (path) to a module is also acceptable and recommended when code is executed by `exec` without module available. 2. Ignore frames by a given pair of module and a qualified name (qualname). See 1) for acceptable modules. The qualname should be unique in that module. 3. Ignore frames by a (non-decorated) function. 4. Ignore frames by a decorated function. In this case, you can specified a tuple with the function and the number of decorators of it. The decorators on the wrapper function inside the decorators should also be counted. Any frames in `varname`, standard libraries, and frames of any expressions like <lambda> are ignored by default. \"\"\" import sys import inspect import distutils.sysconfig as sysconfig import warnings from os import path from fnmatch import fnmatch from abc import ABC , abstractmethod from typing import List , Optional , Union from types import FrameType , ModuleType , FunctionType from executing import Source from .utils import ( IgnoreElemType , IgnoreType , MaybeDecoratedFunctionWarning , cached_getmodule , attach_ignore_id_to_module , frame_matches_module_by_ignore_id , check_qualname_by_source , debug_ignore_frame ) class IgnoreElem ( ABC ): DOCS \"\"\"An element of the ignore list\"\"\" def __init_subclass__ ( cls , attrs : List [ str ]) -> None : DOCS \"\"\"Define different attributes for subclasses\"\"\" def subclass_init ( self , # IgnoreModule: ModuleType # IgnoreFilename/IgnoreDirname: str # IgnoreFunction: FunctionType # IgnoreDecorated: FunctionType, int # IgnoreModuleQualname/IgnoreFilenameQualname: # ModuleType/str, str # IgnoreOnlyQualname: None, str * ign_args : Optional [ Union [ str , int , ModuleType , FunctionType ]] ) -> None : \"\"\"__init__ function for subclasses\"\"\" for attr , arg in zip ( attrs , ign_args ): setattr ( self , attr , arg ) self . _post_init () # save it for __repr__ cls . attrs = attrs cls . __init__ = subclass_init def _post_init ( self ) -> None : \"\"\"Setups after __init__\"\"\" @abstractmethod DOCS def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : \"\"\"Whether the frame matches the ignore element\"\"\" def __repr__ ( self ) -> str : DOCS \"\"\"Representation of the element\"\"\" attr_values = ( getattr ( self , attr ) for attr in self . __class__ . attrs ) # get __name__ if possible attr_values = ( repr ( getattr ( attr_value , '__name__' , attr_value )) for attr_value in attr_values ) attr_values = ', ' . join ( attr_values ) return f \" { self . __class__ . __name__ } ( { attr_values } )\" class IgnoreModule ( IgnoreElem , attrs = [ 'module' ]): DOCS \"\"\"Ignore calls from a module or its submodules\"\"\" def _post_init ( self ) -> None : attach_ignore_id_to_module ( self . module ) def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame module = cached_getmodule ( frame . f_code ) if module : return ( module . __name__ == self . module . __name__ or module . __name__ . startswith ( f ' { self . module . __name__ } .' )) return frame_matches_module_by_ignore_id ( frame , self . module ) class IgnoreFilename ( IgnoreElem , attrs = [ 'filename' ]): \"\"\"Ignore calls from a module by matching its filename\"\"\" def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame # in case of symbolic links return ( path . realpath ( frame . f_code . co_filename ) == path . realpath ( self . filename )) class IgnoreDirname ( IgnoreElem , attrs = [ 'dirname' ]): \"\"\"Ignore calls from modules inside a directory Currently used internally to ignore calls from standard libraries.\"\"\" def _post_init ( self ) -> None : # pylint: disable=access-member-before-definition # pylint: disable=attribute-defined-outside-init if not self . dirname . endswith ( path . sep ): self . dirname = f ' { self . dirname }{ path . sep } ' def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame return path . realpath ( frame . f_code . co_filename ) . startswith ( path . realpath ( self . dirname ) ) class IgnoreFunction ( IgnoreElem , attrs = [ 'func' ]): \"\"\"Ignore a non-decorated function\"\"\" def _post_init ( self ) -> None : if ( # without functools.wraps '<locals>' in self . func . __qualname__ or self . func . __name__ != self . func . __code__ . co_name ): warnings . warn ( f 'You asked varname to ignore function { self . func . __name__ !r} , ' 'which may be decorated. If it is not intended, you may need ' 'to ignore all intermediate frames with a tuple of ' 'the function and the number of its decorators.' , MaybeDecoratedFunctionWarning ) def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame return frame . f_code == self . func . __code__ class IgnoreDecorated ( IgnoreElem , attrs = [ 'func' , 'n_decor' ]): \"\"\"Ignore a decorated function\"\"\" def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : try : frame = frameinfos [ frame_no + self . n_decor ] . frame except IndexError : return False return frame . f_code == self . func . __code__ class IgnoreModuleQualname ( IgnoreElem , attrs = [ 'module' , 'qualname' ]): \"\"\"Ignore calls by qualified name in the module\"\"\" def _post_init ( self ) -> None : attach_ignore_id_to_module ( self . module ) # check uniqueness of qualname modfile = getattr ( self . module , '__file__' , None ) if modfile is not None : check_qualname_by_source ( Source . for_filename ( modfile , self . module . __dict__ ), self . module . __name__ , self . qualname ) def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame module = cached_getmodule ( frame . f_code ) # Return earlier to avoid qualname uniqueness check if module and module != self . module : return False if ( not module and not frame_matches_module_by_ignore_id ( frame , self . module ) ): return False source = Source . for_frame ( frame ) check_qualname_by_source ( source , self . module . __name__ , self . qualname ) return fnmatch ( source . code_qualname ( frame . f_code ), self . qualname ) class IgnoreFilenameQualname ( IgnoreElem , attrs = [ 'filename' , 'qualname' ]): \"\"\"Ignore calls with given qualname in the module with the filename\"\"\" def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame frame_filename = path . realpath ( frame . f_code . co_filename ) preset_filename = path . realpath ( self . filename ) # return earlier to avoid qualname uniqueness check if frame_filename != preset_filename : return False source = Source . for_frame ( frame ) check_qualname_by_source ( source , self . filename , self . qualname ) return fnmatch ( source . code_qualname ( frame . f_code ), self . qualname ) class IgnoreOnlyQualname ( IgnoreElem , attrs = [ '_none' , 'qualname' ]): \"\"\"Ignore calls that match the given qualname, across all frames.\"\"\" def match ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> bool : frame = frameinfos [ frame_no ] . frame # module is None, check qualname only return fnmatch ( Source . for_frame ( frame ) . code_qualname ( frame . f_code ), self . qualname ) def create_ignore_elem ( ignore_elem : IgnoreElemType ) -> IgnoreElem : \"\"\"Create an ignore element according to the type\"\"\" if isinstance ( ignore_elem , ModuleType ): return IgnoreModule ( ignore_elem ) if isinstance ( ignore_elem , str ): return ( IgnoreDirname ( ignore_elem ) if path . isdir ( ignore_elem ) else IgnoreFilename ( ignore_elem )) if hasattr ( ignore_elem , '__code__' ): return IgnoreFunction ( ignore_elem ) if not isinstance ( ignore_elem , tuple ) or len ( ignore_elem ) != 2 : raise ValueError ( f 'Unexpected ignore item: { ignore_elem !r} ' ) # is tuple and len == 2 if ( hasattr ( ignore_elem [ 0 ], '__code__' ) and isinstance ( ignore_elem [ 1 ], int ) ): return IgnoreDecorated ( * ignore_elem ) # otherwise, the second element should be qualname if not isinstance ( ignore_elem [ 1 ], str ): raise ValueError ( f 'Unexpected ignore item: { ignore_elem !r} ' ) if isinstance ( ignore_elem [ 0 ], ModuleType ): return IgnoreModuleQualname ( * ignore_elem ) if isinstance ( ignore_elem [ 0 ], str ): return IgnoreFilenameQualname ( * ignore_elem ) if ignore_elem [ 0 ] is None : return IgnoreOnlyQualname ( * ignore_elem ) raise ValueError ( f 'Unexpected ignore item: { ignore_elem !r} ' ) class IgnoreList : \"\"\"The ignore list to match the frames to see if they should be ignored\"\"\" @classmethod def create ( cls , ignore : Optional [ IgnoreType ]) -> \"IgnoreList\" : \"\"\"Create an IgnoreList object Args: ignore: An element of the ignore list, either A module (or filename of a module) A tuple of module (or filename) and qualified name A function A tuple of function and number of decorators Returns: The IgnoreList object \"\"\" ignore = ignore or [] if not isinstance ( ignore , list ): ignore = [ ignore ] ignore_list = [ create_ignore_elem ( sysconfig . get_python_lib ( standard_lib = True )), create_ignore_elem ( sys . modules [ __package__ ]), create_ignore_elem (( None , '*<lambda>' )), ] for ignore_elem in ignore : ignore_list . append ( create_ignore_elem ( ignore_elem )) return cls ( ignore_list ) def __init__ ( self , ignore_list : List [ IgnoreElemType ]) -> None : self . ignore_list = ignore_list def nextframe_to_check ( self , frame_no : int , frameinfos : List [ inspect . FrameInfo ]) -> int : \"\"\"Find the next frame to check In modst cases, the next frame to check is the next adjacent frame. But for IgnoreDecorated, the next frame to check should be the next `ignore[1]`th frame. Args: frame_no: The index of current frame to check frameinfos: The frame info objects Returns: A number for Next `N`th frame to check. 0 if no frame matched. \"\"\" for ignore_elem in self . ignore_list : matched = ignore_elem . match ( frame_no , frameinfos ) if matched and isinstance ( ignore_elem , IgnoreDecorated ): debug_ignore_frame ( f 'Ignored by { ignore_elem !r} ' , frameinfos [ frame_no ]) return ignore_elem . n_decor + 1 if matched : debug_ignore_frame ( f 'Ignored by { ignore_elem !r} ' , frameinfos [ frame_no ]) return 1 return 0 def get_frame ( self , frame_no : int ) -> FrameType : \"\"\"Get the right frame by the frame number Args: frame_no: The index of the frame to get Returns: The desired frame Raises: VarnameRetrievingError: if any exceptions raised during the process. \"\"\" try : # since this function will be called by APIs # so we should skip that frames = inspect . getouterframes ( sys . _getframe ( 2 ), 0 ) i = 0 while i < len ( frames ): nextframe = self . nextframe_to_check ( i , frames ) # ignored if nextframe > 0 : i += nextframe continue frame_no -= 1 if frame_no == 0 : debug_ignore_frame ( 'Gotcha!' , frames [ i ]) return frames [ i ] . frame debug_ignore_frame ( f 'Skipping ( { frame_no - 1 } more to skip)' , frames [ i ] ) i += 1 except Exception as exc : from .utils import VarnameRetrievingError raise VarnameRetrievingError from exc","title":"varname.ignore"},{"location":"api/source/varname/","text":"SOURCE CODE varname DOCS \"\"\"Dark magics about variable names in python\"\"\" # pylint: disable=unused-import from .utils import ( config , VarnameRetrievingError , QualnameNonUniqueError , MultiTargetAssignmentWarning , MaybeDecoratedFunctionWarning ) from .core import varname , nameof , will __version__ = \"0.6.0\"","title":"varname"},{"location":"api/source/varname.utils/","text":"SOURCE CODE varname. utils DOCS \"\"\"Some internal utilities for varname Attributes: IgnoreElemType: The type for ignore elements IgnoreType: The type for the ignore argument MODULE_IGNORE_ID_NAME: The name of the ignore id injected to the module. Espectially for modules that can't be retrieved by `inspect.getmodule(frame)` \"\"\" import sys import dis import ast import inspect from os import path from functools import lru_cache from types import ModuleType , FunctionType , CodeType , FrameType from typing import Optional , Tuple , Union , List from executing import Source IgnoreElemType = Union [ # module ModuleType , # filename of a module str , FunctionType , # the module (filename) and qualname # If module is None, then all qualname matches the 2nd element # will be ignored. Used to ignore <lambda> internally Tuple [ Optional [ Union [ ModuleType , str ]], str ], # Function and number of its decorators Tuple [ FunctionType , int ] ] IgnoreType = Union [ IgnoreElemType , List [ IgnoreElemType ]] MODULE_IGNORE_ID_NAME = '__varname_ignore_id__' class config : # pylint: disable=invalid-name DOCS \"\"\"Global configurations for varname\"\"\" debug = False class VarnameRetrievingError ( Exception ): DOCS \"\"\"When failed to retrieve the varname\"\"\" class QualnameNonUniqueError ( Exception ): DOCS \"\"\"When a qualified name is used as an ignore element but references to multiple objects in a module\"\"\" class MaybeDecoratedFunctionWarning ( Warning ): DOCS \"\"\"When a suspecious decorated function used as ignore function directly\"\"\" class MultiTargetAssignmentWarning ( Warning ): DOCS \"\"\"When varname tries to retrieve variable name in a multi-target assignment\"\"\" @lru_cache () DOCS def cached_getmodule ( codeobj : CodeType ): \"\"\"Cached version of inspect.getmodule\"\"\" return inspect . getmodule ( codeobj ) def get_node ( DOCS frame : int , ignore : Optional [ IgnoreType ] = None , raise_exc : bool = True ) -> Optional [ ast . AST ]: \"\"\"Try to get node from the executing object. This can fail when a frame is failed to retrieve. One case should be when python code is executed in R pacakge `reticulate`, where only first frame is kept. When the node can not be retrieved, try to return the first statement. \"\"\" from .ignore import IgnoreList ignore = IgnoreList . create ( ignore ) try : frame = ignore . get_frame ( frame ) except VarnameRetrievingError : return None exect = Source . executing ( frame ) if exect . node : return exect . node if exect . source . text and exect . source . tree and raise_exc : raise VarnameRetrievingError ( \"Couldn't retrieve the call node. \" \"This may happen if you're using some other AST magic at the \" \"same time, such as pytest, ipython, macropy, or birdseye.\" ) return None def lookfor_parent_assign ( node : ast . AST ) -> Optional [ ast . Assign ]: DOCS \"\"\"Look for an ast.Assign node in the parents\"\"\" while hasattr ( node , 'parent' ): node = node . parent if isinstance ( node , ( ast . AnnAssign , ast . Assign )): return node return None def node_name ( node : ast . AST ) -> Optional [ Union [ str , Tuple [ Union [ str , tuple ]]]]: DOCS \"\"\"Get the node node name. Raises VarnameRetrievingError when failed \"\"\" if isinstance ( node , ast . Name ): return node . id if isinstance ( node , ast . Attribute ): return node . attr if isinstance ( node , ( ast . List , ast . Tuple )): return tuple ( node_name ( elem ) for elem in node . elts ) raise VarnameRetrievingError ( f \"Can only get name of a variable or attribute, \" f \"not { ast . dump ( node ) } \" ) def bytecode_nameof ( frame : int = 1 ) -> str : DOCS \"\"\"Bytecode version of nameof as a fallback\"\"\" from .ignore import IgnoreList frame = IgnoreList . create ( None ) . get_frame ( frame ) return _bytecode_nameof_cached ( frame . f_code , frame . f_lasti ) @lru_cache () def _bytecode_nameof_cached ( code : CodeType , offset : int ) -> str : \"\"\"Cached Bytecode version of nameof We are trying this version only when the sourcecode is unavisible. In most cases, this will happen when user is trying to run a script in REPL/ python shell, with `eval`, or other circumstances where the code is manipulated to run but sourcecode is not available. \"\"\" instructions = list ( dis . get_instructions ( code )) ( current_instruction_index , current_instruction ), = ( ( index , instruction ) for index , instruction in enumerate ( instructions ) if instruction . offset == offset ) if current_instruction . opname not in ( \"CALL_FUNCTION\" , \"CALL_METHOD\" ): raise VarnameRetrievingError ( \"Did you call nameof in a weird way?\" ) name_instruction = instructions [ current_instruction_index - 1 ] if not name_instruction . opname . startswith ( \"LOAD_\" ): raise VarnameRetrievingError ( \"Argument must be a variable or attribute\" ) name = name_instruction . argrepr if not name . isidentifier (): raise VarnameRetrievingError ( f \"Found the variable name { name !r} which is obviously wrong. \" \"This may happen if you're using some other AST magic at the \" \"same time, such as pytest, ipython, macropy, or birdseye.\" ) return name def attach_ignore_id_to_module ( module : ModuleType ) -> None : DOCS \"\"\"Attach the ignore id to module This is useful when a module cannot be retrieved by frames using `inspect.getmodule`, then we can use this id, which will exist in `frame.f_globals` to check if the module matches in ignore. Do it only when the __file__ is not avaiable or does not exist for the module. Since this probably means the source is not avaiable and `inspect.getmodule` would not work \"\"\" module_file = getattr ( module , '__file__' , None ) if module_file is not None and path . isfile ( module_file ): return # or it's already been set if hasattr ( module , MODULE_IGNORE_ID_NAME ): return setattr ( module , MODULE_IGNORE_ID_NAME , f '<varname-ignore- { id ( module ) } )' ) def frame_matches_module_by_ignore_id ( DOCS frame : FrameType , module : ModuleType ) -> bool : \"\"\"Check if the frame is from the module by ignore id\"\"\" ignore_id_attached = getattr ( module , MODULE_IGNORE_ID_NAME , object ()) ignore_id_from_frame = frame . f_globals . get ( MODULE_IGNORE_ID_NAME , object ()) return ignore_id_attached == ignore_id_from_frame @lru_cache () DOCS def check_qualname_by_source ( source : Source , modname : str , qualname : str ) -> None : \"\"\"Check if a qualname in module is unique\"\"\" if not source . tree : # no way to check it, skip return nobj = list ( source . _qualnames . values ()) . count ( qualname ) if nobj > 1 : raise QualnameNonUniqueError ( f \"Qualname { qualname !r} in \" f \" { modname !r} refers to multiple objects.\" ) def debug_ignore_frame ( DOCS msg : str , frameinfo : Optional [ inspect . FrameInfo ] = None ) -> None : \"\"\"Print the debug message for a given frame info object Args: msg: The debugging message frameinfo: The FrameInfo object for the frame \"\"\" if not config . debug : return if frameinfo is not None : msg = ( f ' { msg } [In { frameinfo . function !r} at ' f ' { frameinfo . filename } : { frameinfo . lineno } ]' ) sys . stderr . write ( f '[ { __name__ } ] DEBUG: { msg } \\n ' )","title":"varname.utils"}]}